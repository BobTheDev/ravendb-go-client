package ravendb

import (
	"sync"
	"time"
)

// TODO: write tests
// TODO: make private to package if not exposed in public APIs

// CompletableFuture helps porting Java code. Implements only functions needed
// by ravendb.
type CompletableFuture struct {
	mu        sync.Mutex

	completed bool
	// used to wait for Future to finish
	signalCompletion chan bool

	// result generated by the Future, only valid if completed
	result interface{}
	err    error
}

func NewCompletableFuture() *CompletableFuture {
	return &CompletableFuture{
		// channel with capacity 1 so that Complete() can finish the goroutine
		// without waiting for someone to call Get()
		signalCompletion: make(chan bool, 1),
	}
}

func NewCompletableFutureAlreadyCompleted(result interface{}) *CompletableFuture {
	res := NewCompletableFuture()
	res.Complete(result)
	return res
}

func (f *CompletableFuture) getState() (bool, interface{}, error) {
	f.mu.Lock()
	defer f.mu.Unlock()
	return f.completed, f.result, f.err
}

func (f *CompletableFuture) IsDone() bool {
	done, _, _ := f.getState()
	return done
}

func (f *CompletableFuture) IsCompletedExceptionally() bool {
	_, err, _ := f.getState()
	return err != nil // implies f.done
}

// must be called with f.mu locked
func (f *CompletableFuture) markCompleted(result interface{}, err error) {
	f.completed = true
	f.result = result
	f.err = err
	f.signalCompletion <- true
}

func (f *CompletableFuture) Complete(result interface{}) {
	f.mu.Lock()
	if !f.completed {
		f.markCompleted(result, nil)
	}
	f.mu.Unlock()
}

// TODO: maybe rename to CompleteWithError() since doesn't have exceptions
func (f *CompletableFuture) CompleteExceptionally(err error) {
	f.mu.Lock()
	if !f.completed {
		f.markCompleted(nil, err)
	}
	f.mu.Unlock()
}

// Get waits for completion and returns resulting value or error
// If already completed, returns immediately.
func (f *CompletableFuture) Get() (interface{}, error) {
	done, res, err := f.getState()
	if done {
		return res, err
	}

	// wait for the Future to complete
	<-f.signalCompletion

	_, res, err = f.getState()
	return res, err
}

func (f *CompletableFuture) GetWithTimeout(dur time.Duration) (interface{}, error) {
	done, res, err := f.getState()
	if done {
		return res, err
	}

	// wait for the Future to complete or timeout to expire
	select {
	case <-f.signalCompletion:
		// completed, will return the result
	case <-time.After(dur):
		// timed out
		return nil, NewTimeoutException("GetWithTimeout() timed out after", dur)
	}

	_, res, err = f.getState()
	return res, err
}
