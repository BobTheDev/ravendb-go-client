package ravendb

import "sync"

// TODO: write tests

// CompletableFuture helps porting Java code
type CompletableFuture struct {
	mu   sync.Mutex
	done bool
	// used to wait for Future to finish
	chDone chan bool
	// result generated by the Future, only valid if completed
	result interface{}
	err    error
}

func NewCompletableFuture() *CompletableFuture {
	return &CompletableFuture{
		// channel with capacity 1 so that markAsDone() can finish the goroutine
		// without waiting for someone to call get()
		chDone: make(chan bool, 1),
	}
}

func NewCompletableFutureAlreadyCompleted(result interface{}) *CompletableFuture {
	res := NewCompletableFuture()
	res.markAsDone(result)
	return res
}

func (f *CompletableFuture) isDone() bool {
	f.mu.Lock()
	res := f.done
	f.mu.Unlock()
	return res
}

func (f *CompletableFuture) isCompletedExceptionally() bool {
	f.mu.Lock()
	res := f.err != nil // implies f.done
	f.mu.Unlock()
	return res
}

func (f *CompletableFuture) markAsDone(result interface{}) {
	f.mu.Lock()
	defer f.mu.Unlock()
	if f.done {
		return
	}
	f.done = true
	f.result = result
	f.chDone <- true
}

func (f *CompletableFuture) markAsDoneWithError(err error) {
	f.mu.Lock()
	defer f.mu.Unlock()
	if f.done {
		return
	}
	f.done = true
	f.err = err
	f.chDone <- true
}

func (f *CompletableFuture) get() (interface{}, error) {
	f.mu.Lock()
	if f.done {
		res, err := f.result, f.err
		f.mu.Unlock()
		return res, err
	}
	f.mu.Unlock()
	// wait for the Future to finish
	<-f.chDone

	f.mu.Lock()
	res, err := f.result, f.err
	f.mu.Unlock()
	return res, err
}
